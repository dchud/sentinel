_q_exports = [
    '_q_index',
    'add',
    'create',
    'receive',
    ]

import os
import stat
import traceback

from quixote import get_publisher
from quixote.errors import AccessError, PublishError, TraversalError
from quixote import form2
from quixote.html import html_quote

from dulcinea.database import get_transaction

from canary.ui.admin.admin_ui import title_bar
from canary.ui.pageframe import header, footer
from canary.ui.pages import not_found, add_message, has_messages, render_messages
from canary.loader import Batch, Queue, Parser
from canary.qx_defs import MyForm
from canary.source_catalog import SourceCatalog, Source


def _q_index [html] (request):
    header('Queue:')
    """
    <h2>Queue</h2>
    """
    footer()


class QueueActions:

    _q_exports = [
        '_q_index',
        'edit',
        ]

    def __init__ (self, batch_id):
        self.batch_id = batch_id
        
    def _q_index [html] (self, request):
        header('Admin: Term summary')
        """
        <h2>Term summary</h2>
        """
        footer()

    def _q_lookup [html] (self, request, action):
        try:
            if action == 'edit':
                return edit(request, self.batch_id)
            if action == 'delete':
                return delete(request, self.batch_id)
            else:
                raise TraversalError
        except:
            import traceback
            print traceback.print_exc()
            return not_found('queue')
            
            
    def edit [html] (self, request):
        
        cursor = get_publisher().get_cursor()
        batch = Batch(uid=self.batch_id)
        batch.load(cursor, load_metadata=False)
        
        source_catalog = get_publisher().get_source_catalog()
        # Sort terms by their token
        sources = [(id, source.name) for id, source in source_catalog.sources.items()]
        sources.sort()
        
        form = MyForm()
        form.add(form2.StringWidget, 'batch_name', 
            title='Batch name',
            value=batch.name,
            size=40,
            required=True)
        form.add(form2.SingleSelectWidget, 'source_id', 
            title='Source',
            options=[(id, name, id) for id, name in sources],
            value=batch.source_id,
            sort=True,
            required=True)
        form.add_submit('edit', 'edit')
        
        def render [html] ():
            header('Edit batch')
            title_bar('Edit batch %s' % self.batch_id)
            form.render()
            footer()
        
        if not form.is_submitted():
            form.get_widget('batch_name').set_value(batch.name)
            form.get_widget('source_id').set_value(batch.source_id)
            return render()
            
        has_changed = False
        if not form['batch_name'] == batch.name:
            has_changed = True
            batch.name = form['batch_name']
        if not form['source_id'] == batch.source_id:
            has_changed = True
            batch.source_id = form['source_id']
        
        if form.has_errors():
            return render()
        
        if has_changed:
            try:
                batch.save(cursor)
                add_message('Edited batch %s' % self.batch_id)
                form.logger.info(str('Edited batch %s' % self.batch_id))
            except:
                add_message('Could not edit batch')
                form.logger.info(str('Could not edit batch'))
        else:
            add_message('Batch unchanged')
        
        cursor.close()
        request.redirect(str('/admin/queue/list'))




def add [html] (request):

    source_catalog = get_publisher().get_source_catalog()

    # Sort terms by their token
    sources = [(id, source.name) for id, source in source_catalog.sources.items()]
    sources.sort()

    header('Upload records')
    title_bar('Upload records')

    if has_messages():
        render_messages()

    """
    <form enctype='multipart/form-data'
        method='POST'
        action='receive'>
    <p>
    Source:<br/>
        <select name='source_id'><br/>

    """
    for id, name in sources:
        """
        <option value='%s'>%s
        """ % (id, name)
    """
        </select>
    </p>

    <p>
    File to upload: <br/>
        <input type='file' name='upload' />
    </p>

    <p>
    Expected #records: <br/>
        <input type='text' name='num_records' size='4' />
    </p>
    
    <p>
    Batch name: <br/>
        <input type='text' name='batch_name' size='30' />
    </p>
    
    <p>
        <input type='submit' value='Upload' />
    </p>
    </form>
    """
    footer()



def list [html] (request):

    cursor = get_publisher().get_cursor()
    source_catalog = get_publisher().get_source_catalog()

    # Sort terms by their token
    sources = [(id, source.name) for id, source in source_catalog.sources.items()]
    sources.sort()

    header('List editing queues')
    title_bar('List editing queues')
    if has_messages():
        render_messages()

    """
    <table cellspacing='5' class='gentable'>
    <tr>
        <th>Batch</th>
        <th>Name</th>
        <th>Source</th>
        <th>Status (unclaimed/claimed/curated/total (% done))</th>
        <th>Load date</th>
        <th>Actions</th>
    </tr>
    """
    queue = Queue()
    queue.load(cursor)
    for batch in queue.batches:
        batch_stats = batch.get_statistics(cursor)

        source_id = batch.source_id
        source = source_catalog.get_source(source_id)
        """
        <tr>
            <td>%s</td>
            <td>%s</td>
            <td>%s</td>
        """ % (batch.uid, batch.name, source.name)
        
        # Avoid division by zero for empty batches
        if batch.num_records > 0:
            percent_done = float(batch_stats['curated']) / batch.num_records * 100.0
        else:
            percent_done = 0
        """
            <td>%s / %s / %s / %s (%s%s done)</td>
        """ % (batch_stats['unclaimed'],
            batch_stats['claimed'],
            batch_stats['curated'],
            batch.num_records,
            str('%2.1f' % percent_done),
            str('%'))
        """
            <td>%s</td>
            <td>[<a href='/admin/queue/%s/edit'>edit</a>]</td>
        </tr>
        """ % (str(batch.date_added)[0:10], batch.uid)
    """
    </table>
    """
    
    cursor.close()
    footer()
    

def receive [html] (request):

    result = []
    form = request.form
    request.session.message = None

    try:
        source_id = int(form.get('source_id'))
        source_catalog = get_publisher().get_source_catalog()
        source = source_catalog.get_source(source_id)
    except:
        request.session.message = str('Please choose a source.')
        return add(request)

    try:
        num_records = int(form.get('num_records'))
    except:
        request.session.message = str('Please enter the number of expected records.')
        return add(request)

    # FIXME: Think through this better.  Should clean up empty files at least.
    try:
        upload = request.form.get('upload')
        size = os.stat(upload.tmp_filename)[stat.ST_SIZE]
        if not upload.base_filename or size == 0:
            request.session.message = str('Nothing uploaded.')
    except:
        request.session.message = str('Upload failed.')
        return add(request)

    try:
        cursor = get_publisher().get_cursor()
        batch = Batch(file_name=upload.tmp_filename, source_id=source_id)
        batch.name = form.get('batch_name') or ''
        batch.save(cursor)
        source_catalog = get_publisher().get_source_catalog()
        source = source_catalog.get_source(source_id)
        mapped_terms = source_catalog.get_mapped_terms(source_id)
        parser = Parser(source)
        records = parser.parse(upload.tmp_filename, mapped_terms=mapped_terms)
        if num_records == len(records):
            batch.add_records(records)
            batch.save(cursor)
        else:
            print 'count mismatch'
            request.session.message = str('Batch not saved: Record count mismatch, %s specified, %s found') % (num_records, len(records))

        cursor.close()
    except:
        print traceback.print_exc()
        request.session.message = str('Unable to load batch.')

    if request.session.message:
        # FIXME:  do cleanup here?
        return add(request)

    header('Uploaded records')
    """
    <p>You just uploaded <code>%s</code> (%d bytes)<br>
    """ % (html_quote(upload.base_filename), size)
    """
    which is temporarily stored in <code>%s</code>.</p>
    """ % html_quote(upload.tmp_filename)
    """
    <p>And has id %s and date_added %s.</p>
    """ % (batch.uid, batch.date_added)

    footer()


def create [html] (request):

    source_catalog = get_publisher().get_source_catalog()

    # Sort terms by their token
    sources = [(id, source.name) for id, source in source_catalog.sources.items()]
    sources.sort()

    form = MyForm()
    form.add(form2.SingleSelectWidget, name='source_id', title='Source',
        options=[(id, name, id) for id, name in sources],
        sort=True,
        required=True)
    form.add(form2.StringWidget, 'batch_name', title='Batch name',
        size=25, required=True)
    form.add_submit('create', 'create')
    
    def render [html] ():
        header('Create batch')
        title_bar('Create batch')
        form.render()
        footer()

    if not form.is_submitted():
        return render()
        
    try:
        cursor = get_publisher().get_cursor()
        batch = Batch(source_id=form['source_id'])
        batch.name = form['batch_name']
        batch.save(cursor)
        cursor.close()
        add_message('Created batch %s' % batch.uid)
        form.logger.info(str('Created batch %s' % batch.uid))
    except:
        add_message('Could not create batch')
        form.logger.info(str('Could not create batch'))
    
    request.redirect(str('/admin'))
