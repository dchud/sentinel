# $Id$

import logging
import string
import traceback
import urllib

from quixote import get_publisher, get_request
from quixote.html import htmltext

from canary.browse import records_by_year, records_by_year_index
from canary.browse import records_by_heading, records_by_heading_index
from canary.browse import records_by_journal, records_by_journal_index
from canary.browse import records_by_methodology, records_by_methodology_index
from canary.browse import records_by_author, records_by_author_index
from canary.browse import records_by_concept, records_by_concept_index
from canary.concept import Concept
from canary.qx_defs import NotLoggedInError
from canary.study import Methodology, Study
from canary.ui.pages import not_found
from canary.ui.pageframe import header, footer
from canary.ui.record_ui import render_record_row
from canary import utils


class Browse:

    _q_exports = [
        '_q_index',
        ]
        
    def __init__ (self, request):
        pass

    def _q_index [html] (self, request):
        header('Browse')
        """
        <h2>Browse</h2>
        
        <p>
        You can browse the database by clicking on the available 
        indexes under "Browse by" at left.
        </p>
        """
        footer()
    
    def _q_lookup (self, request, name):
        try:
            if name == 'year':
                return YearBrowseIndex(request)
            #elif name == 'heading':
            #    return HeadingBrowseIndex(request)
            elif name == 'journal':
                return JournalBrowseIndex(request)
            elif name == 'methodology':
                return MethodologyBrowseIndex(request)
            elif name == 'author':
                return AuthorBrowseIndex(request)
            elif name == 'exposure':
                return ConceptBrowseIndex(request, 'exposure')
            elif name == 'outcome':
                return ConceptBrowseIndex(request, 'outcome')
            elif name == 'species':
                return ConceptBrowseIndex(request, 'species')
            elif name == 'risk_factor':
                return ConceptBrowseIndex(request, 'risk_factor')
            else:
                raise 'NotFoundError'
        except:
            return not_found('index')
            

def render_on_this_page_concept [html] (type, concept_sorted, total, query_string=''):
    """
        <tr>
            <td colspan='4' align='left'>
            <h3 style='font-size:12;margin-top:.6em;margin-bottom:.2em;'>%s</h3>
            </td>
        </tr>
    """ % type.capitalize()
    for count, con in concept_sorted[0:8]:
        """
        <tr style='background-color:#fafafa;'>
        """
        percentage = int((float(count) / total) * 100)
        count_str = '%s%s' % (percentage, '%')
        """
            <td valign='top'>
                <div class='page-relevance-box' title='%s of studies on this page'>
                    <div class="relevance" style="width: %s"><img src='/images/pixel.gif' alt='' width='' height=''></div>
                </div>
            </td>
        """ % (count_str, count_str)
        """
            <td style='margin-right:.3em;' valign='top'>
                <a style='font-size:11px;' 
                    href='/search?q="%s"[%s]'
                    title='Search for: "%s" [%s]'>%s</a>
            </td>
        """ % (con, type, 
            con, type, con)
        query = '"%s"[%s]' % (con, type)
        or_query = and_query = query_string
        if not str(query) in str(query_string):
            or_query = '%s OR %s' % (query_string, query)
            and_query = '%s %s' % (query_string, query)
        """
            <td valign='top'>
                <a href='/search?q=%s' title='Search for: %s'><img src='/images/basic-boolean-and.jpg' alt='Search for: %s' border='0'/></a>
            </td>
            <td valign='top'>
                <a href='/search?q=%s' title='Search for: %s'><img src='/images/basic-boolean-or.jpg' alt='Search for: %s' border='0'/></a>
            </td>
        """ % (and_query, and_query, and_query,
            or_query, or_query, or_query)
        """
        </tr>
        """

def render_on_this_page [html] (records, query_string=''):
    context = get_publisher().context
    source_catalog = context.get_source_catalog()
    complete_term_mapping = source_catalog.get_complete_mapping()
    
    num_records = len(records)
    authors = {}
    exposures = {}
    outcomes = {}
    species = {}
    for sort_value, rec in records:
        study = Study(context, rec.study_id)
        mm = rec.get_mapped_metadata(complete_term_mapping)
        author = mm['author']
        for a in author:
            try:
                authors[a] += 1
            except KeyError:
                authors[a] = 1
        for exp in study.exposures:
            try:
                exposures[exp.term] += 1
            except KeyError:
                exposures[exp.term] = 1
        for out in study.outcomes:
            try:
                outcomes[out.term] += 1
            except KeyError:
                outcomes[out.term] = 1
        for spec in study.species:
            try:
                species[spec.term] += 1
            except KeyError:
                species[spec.term] = 1
        
        
    
    """
    <div style='border:1px solid #AAAAAA;padding:.5em;margin-bottom:1em;'>
    
    <h3>Find similar:</h3>
    
    <div class='label'>
        <span id='hideable-link'>Show/hide</span>
    </div>
           
    <div class='hideable'>
    <table width='100%' border='0' cellspacing='1' cellpadding='0'>
        <tr style='margin-top:.6em;margin-bottom:.2em;background-color:#fafafa;'>
            <th style='font-size:11px;' align='center'>%</th>
            <th style='font-size:11px;'>-</th>
            <th style='font-size:11px;'>and</th>
            <th style='font-size:11px;'>&nbsp;or</th>
        </tr>
    """
    
    exposures_sorted = [(v, k) for k, v in exposures.items()]
    exposures_sorted.sort()
    exposures_sorted.reverse()
    if exposures_sorted:
        render_on_this_page_concept('exposure', exposures_sorted, num_records,
            query_string)

    outcomes_sorted = [(v, k) for k, v in outcomes.items()]
    outcomes_sorted.sort()
    outcomes_sorted.reverse()
    if outcomes_sorted:
        render_on_this_page_concept('outcome', outcomes_sorted, num_records,
            query_string)
            
    species_sorted = [(v, k) for k, v in species.items()]
    species_sorted.sort()
    species_sorted.reverse()
    if species_sorted:
        render_on_this_page_concept('species', species_sorted, num_records,
            query_string)
            
    authors_sorted = [(v, k) for k, v in authors.items()]
    authors_sorted.sort()
    authors_sorted.reverse()
    if authors_sorted:
        render_on_this_page_concept('author', authors_sorted, num_records,
            query_string)
            
    """
    </table>
    </div>
    """
        


class BrowseIndex:
    
    _q_exports = [
        '_q_index',
        ]
    
    # Subclasses can be sorted by any of these attributes
    SORT_FIELDS = ['year']
    
    # Subclasses are sorted by default by this attribute
    SORT_FIELD_DEFAULT = 'year'
    
    # Subclasses are sorted by default in this order
    SORT_BY_DESCENDING = True

    # Supported pager sizes; anything else will be ignored
    ALLOWED_SIZES = (10, 25, 50, 100)

    def __init__ (self):
        self.type = 'superclass'
        self.logger = logging.getLogger(str(self.__class__))
        
    def _q_index [html] (self, request):
        pass
        
    def get_pager_params (self):
        """
        Fetch requested or provide default pager parameters, ignoring
        improper value types.
        """
        request = get_request()
        params = {}
        
        try:
            params['size'] = int(request.get_form_var('size', 10))
            if not params['size'] in self.ALLOWED_SIZES:
                raise ValueError
        except ValueError:
            params['size'] = 10
            
        try:
            params['start'] = int(request.get_form_var('start', 0))
        except ValueError:
            params['start'] = 0
            
        try:
            sort_by = str(request.get_form_var('sort_by', 
                self.SORT_FIELD_DEFAULT))
            if sort_by in self.SORT_FIELDS:
                params['sort_by'] = sort_by
            else:
                raise ValueError
        except ValueError:
            params['sort_by'] = self.SORT_FIELD_DEFAULT
        
        try:
            sort_desc = int(request.get_form_var('sort_desc', 
                int(self.SORT_BY_DESCENDING)))
            if sort_desc in (0, 1):
                params['sort_desc'] = sort_desc
            else:
                raise ValueError
        except ValueError:
            params['sort_desc'] = int(self.SORT_BY_DESCENDING)
            
        return params


    def pager [html] (self, records, params={}):
        
        p = params
        total = len(records)
       
        # total number of pages, by size, in this list
        num_pages = total / p['size']
        remainder = total % p['size']
        if remainder:
            num_pages += 1
    
        # currently viewed page, as determined by size, within this list
        cur_page = p['start'] / p['size']
        """
        <p>
        """
        if len(records) >= 2:
            """
            Sort by:
            """
            for sort_field in self.SORT_FIELDS:
                if sort_field == p['sort_by']:
                    ' [<b>%s</b>] ' % sort_field
                else:
                    ' [<a href="?size=%s&sort_by=%s&sort_desc=%s">%s</a>] ' % \
                        (p['size'], sort_field, p['sort_desc'], sort_field)
            
            """
            &nbsp;-&nbsp;
            """
            if 'year' == p['sort_by']:
                text_asc = '0-9'
                text_desc = '9-0'
            else:
                text_asc = 'A-Z'
                text_desc = 'Z-A'
                
            if p['sort_desc']:
                ' [<a href="?size=%s&sort_by=%s&sort_desc=0">%s</a>] ' % \
                    (p['size'], p['sort_by'], text_asc)
                ' [<b>%s</b>] ' % text_desc
            else:
                ' [<b>%s</b>] ' % text_asc
                ' [<a href="?size=%s&sort_by=%s&sort_desc=1">%s</a>] ' % \
                    (p['size'], p['sort_by'], text_desc)

        # no need to show the pager if there's only one page
        if num_pages > 1:

            # We only need the spacing if there's a "sort by" above it
            if len(records) >= 2:
                """
                <br />
                """
                
            """
            Show:
            """    
            sizes = [min(self.ALLOWED_SIZES)]
            if total > max(self.ALLOWED_SIZES):
                sizes.extend(self.ALLOWED_SIZES[1:])
            else:
                # Don't show "group by 100" if there are only 13 records
                for bigger_size in self.ALLOWED_SIZES[1:]:
                    if not max(sizes) > total:
                        sizes.append(bigger_size)
                
            for s in sizes:
                text = s
                if s == total:
                    text = 'all'
                    
                if p['size'] == s:
                    ' [<b>%s</b>] ' % text
                else:
                    ' [<a href="?size=%s&sort_by=%s&sort_desc=%s">%s</a>] ' % \
                        (s,  p['sort_by'], p['sort_desc'], text)
            """
            per page <br />
            """
            
            """
            Go to: 
            """
            for i in range(0, num_pages):
                start = str((i * p['size']) + 1)
                if remainder \
                    and (i+1) == num_pages:
                    end = str((i * p['size']) + remainder)
                else:
                    end = str((i + 1) * p['size'])
                text = start + '-' + end
                if i != cur_page:
                    ' [<a href="?start=%s&size=%s&sort_by=%s&sort_desc=%s">%s</a>] ' % \
                        (i * p['size'], p['size'], p['sort_by'], p['sort_desc'], text)
                else:
                    ' [<b>%s</b>] ' % text
            
        """
        </p>
        """


    
    def letter_index [html] (self, values, current_value=None, text='',
        show_numbers=False):
        # Generate a browse-by-letter index view 
        lindex = {}
        for c in range(65, 91):
            lindex[chr(c)] = 0
        if show_numbers:
            for i in range(0,10):
                lindex[str(i)] = 0
                
        for val in [v[0].capitalize() for v in values]:
            lindex[val] += 1
        
        """
        <p>
        %s
        """ % text or 'Starting with:'
        
        keys = lindex.keys()
        keys.sort()
        for key in keys:
            if lindex[key]:
                if key == current_value.upper():
                    """
                    [<b>%s</b>]
                    """ % key
                else:
                    """
                    [<a href='?l=%s'>%s</a>]
                    """ % (key, key)
            else:
                """
                %s
                """ % key
        
        """
        </p>
        """



    def render_records [html] (self, name, records):
        context = get_publisher().context
        source_catalog = context.get_source_catalog()
        complete_term_mapping = source_catalog.get_complete_mapping()
        
        header('Browse by %s: %s' % (self.type.capitalize(), name),
            show_javascript=True)
        count = len(records)
        if count > 0:
            if count == 1:
                article_text = 'article'
            else:
                article_text = 'articles'
    
            """
            <h2><a href='/browse/%s'>Browse by %s</a>: %s (%s %s)</h2>
            """ % (self.type, self.type.capitalize(), name, count, article_text)
            
            try:
                year_count = {}
                for i in range(1965, 2006):
                    year_count[i] = 0
                for rec in records:
                    mm = rec.get_mapped_metadata(term_map=complete_term_mapping)
                    try:
                        year = int(mm['pubdate'][:4])
                        year_count[year] += 1
                    except:
                        # Somehow the first four digits of pubdate aren't YYYY
                        continue
                        
                        
                # Process all paging info up front so we can optionally
                # pass context years for a subset into make_sparkline()
                        
                years = year_count.keys()
                years.sort()
                p = self.get_pager_params()

                sort_by = p['sort_by']
                complete_term_map = source_catalog.get_complete_mapping()
                records_sorted = []
                for record in records:
                    mm = record.get_mapped_metadata(complete_term_map)
                    if sort_by == 'year':
                        sort_value = mm[str('pubdate')][:4]
                    elif sort_by == 'journal':
                        sort_value = mm[str('journal')].lower()
                    elif sort_by == '1au':
                        authors = mm[str('author')]
                        if authors:
                            sort_value = authors[0].lower()
                        else:
                            sort_value = ''
                    else:
                        pass
                    records_sorted.append((sort_value, record))
                        
                records_sorted.sort()
                if p['sort_desc']:
                    records_sorted.reverse()
                    
                start = p['start']
                end = start + p['size']
                records_sliced = records_sorted[start:end]
                
                # Only shade the year-context in the sparkline if it's a 
                # year sort.
                if p['sort_by'] == 'year':
                    try:
                        start_mm = records_sliced[0][1].get_mapped_metadata(complete_term_map)
                        min_year = max_year = int(start_mm[str('pubdate')][:4])
                        for sort_value, rec in records_sliced[1:]:
                            mm = rec.get_mapped_metadata(complete_term_map)
                            year = int(mm[str('pubdate')][:4])
                            if year < min_year:
                                min_year = year
                            if year > max_year:
                                max_year = year
                            
                        sparkline_image_file = utils.make_sparkline(context, year_count, 
                            context_years=(min_year, max_year))
                    except Exception, e:
                        self.logger.error('Could not specify context years: %s', e)
                        sparkline_image_file = utils.make_sparkline(context, year_count)
                else:
                    sparkline_image_file = utils.make_sparkline(context, year_count)
                
                try:
                    studies = [Study(context, rec.study_id) for sort_value, rec in records_sliced]
                    e_image_file = utils.make_sideways_e(context, studies)
                    context.logger.debug('e_image_file: %s', e_image_file)
                except:
                    context.logger.error(traceback.print_exc())

                """
                <p>
                %s of records by year:
                    <span style='font-weight:bold;font-size:x-small;'>1965</span>
                    <img border='0' src='/timage/%s' type='image/png' usemap='#sparkmap'/>
                    <span style='font-weight:bold;font-size:x-small;'>2005</span>
                    &nbsp;
                    Linkages:
                    <img border='0' src='/timage/%s' type='image/png' usemap='#emap'/>
                </p>
                """ % ('%', sparkline_image_file, e_image_file)
                
                """
                <map name='sparkmap'>
                """
                # rect order is: left-x, top-y, right-x, bottom-y
                for year in years:
                    count = year_count[year]
                    if count > 0:
                        year_index = years.index(year)
                        query_str = '"%s" [%s] %s [date]' \
                            % (name, self.type, year)
                        """
                    <area href='/search?q=%s' 
                        shape='rect'
                        coords='%s %s %s %s'
                        alt='%s'
                        title='%s' />
                        """ % (query_str,
                            year_index*3, 0, (year_index*3)+2, 120,
                            'limit to year %s' % year,
                            'limit to year %s' % year)
                """
                </map>
                
                <map name='emap'>
                """
                bar_width = 4
                for att in utils.linkages:
                    token = att.replace(str('_'), str('-'))
                    query_str = '"%s" [%s] has-%s' % (name, self.type, token)
                    xoffset = 2 + (utils.linkages.index(att)*9)
                    """
                    <area href='/search?q=%s:1'
                        shape='rect'
                        coords='%s %s %s %s'
                        alt='%s'
                        title='%s' />
                    """ % (query_str,
                        xoffset, 0, xoffset+bar_width, 20,
                        'limit to studies with %s = True' % token, 
                        'limit to studies with %s = True' % token)
                
                """
                </map>
                
                <table width='100%' border='0' cellspacing='2' cellpadding='2'>
                <tr>
                    <td valign='top'>
                """
                
                self.pager(records, params=p)
                
                """
                <div id="search-result">
                    <table width='100%' border='0' cellspacing='0' cellpadding='0'>
                """
                for sort_val, rec in records_sliced:
                    render_record_row(rec)
                """
                    </table>
                </div>
                """
                self.pager(records, params=p)
                """
                    </td>
                    
                    <td width='30%' valign='top'>
                """
                render_on_this_page(records_sliced, '"%s"[%s]' % (name, self.type))
                """
                    </td>
                </tr>
                </table>
                """
                
            except:
                context.logger.error(traceback.print_exc())
                return not_found(self.type)
        else:
            return not_found(self.type)
            
        footer()




class YearBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
        
    SORT_FIELDS = ['journal', '1au']
    
    SORT_FIELD_DEFAULT = '1au'
    
    SORT_BY_DESCENDING = False
    
    def __init__ (self, request):
        self.type = 'year'
        self.logger = logging.getLogger(str(self.__class__))
        
    def _q_index [html] (self, request):
        header('Browse by Year')
        """
        <h2>Browse by Year</h2>
    
        <p>
    Below is a list of the number of articles in the Canary Database by their
    year of publication.
        </p>
    
        <div id="table-list">
            <table cellspacing='3'>
                <tr>
                    <th align='center' width='75'># articles</th>
                    <th align='left'>Year</th>
                </tr>
        """
        context = get_publisher().context
        source_catalog = context.get_source_catalog()
        complete_term_map = source_catalog.get_complete_mapping()
        records = records_by_year_index(context, complete_term_map)
        for record in records:
            year_count, year = record
            if not year == 0:
                """
                <tr>
                    <td align='center'>%s</td>
                    <td align='center'><a href='/browse/year/%s'>%s</a></td>
                </tr>
                """ % (year_count, year, year)
        """
            </table>
        </div>
        """
        footer()
        

    def _q_lookup (self, request, year):
        try:
            if year:
                year = int(year)
                context = get_publisher().context
                source_catalog = context.get_source_catalog()
                complete_term_map = source_catalog.get_complete_mapping()
                records = records_by_year(context, year, term_map=complete_term_map)
                if len(records) == 0:
                    raise Exception('No records found')
                return self.render_records(year, records)
            else:
                raise Error
        except:
            return not_found(self.type)
            



class HeadingBrowseIndex (BrowseIndex):

    _q_exports = [
        '_q_index',
        ]
        
    def __init__ (self, request):
        self.type = 'heading'
        
    def _q_index [html] (self, request):
        header('Browse by Heading')
        """
        <h2>Browse by Heading</h2>
    
        <p>
        Below is a list of the most well-used MeSH headings (indexed by
        NLM) as found in our curated articles.  Please note that in many
        cases, a single article might be indexed with the same heading multiple
        times, when multiple qualifers are attached to the MeSH heading:
        <ul>
            <li>'<b># uses</b>' is the total number of times a heading
        appears as an index term;</li>
            <li>'<b># articles</b>' is the total number of articles in which
        the same heading appears as an index term at least once.</li>
        </ul>
        </p>
        """
    
        """
        <table width='70%' cellspacing='3' cellpadding='3'>
            <tr>
                <th align='center' width='20%'># uses</th>
                <th align='center' width='15%'># articles</th>
                <th align='left'>Subject heading</th>
            </tr>
        """
        context = get_publisher().context
        headings = records_by_heading_index(context)
        for heading in headings:
            term, term_count, id_count = heading
            encoded_heading = urllib.quote_plus(term)
            """
            <tr>
                <td align='center'>%(term_count)s</td>
                <td align='center'>%(id_count)s</td>
                <td align='left'><a href='/browse/heading/%(encoded_heading)s'>%(term)s</a></td>
            </tr>
            """ % vars()
        """
        </table>
        """
        footer()

    
    def _q_lookup (self, request, name):
        try:
            if name:
                unencoded_name = urllib.unquote_plus(name)
                records = records_by_heading(unencoded_name)
                return self.render_records(unencoded_name, records)
            else:
                raise Error
        except:
            return not_found(self.type)
            



class JournalBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
    
    SORT_FIELDS = ['year', '1au']
    
    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True
    
    def __init__ (self, request):
        self.type = 'journal'
        
    def _q_index [html] (self, request):

        header('Browse by %s' % self.type.capitalize())
        """
        <h2><a href='/browse/journal'>Browse by Journal</a></h2>
        """
        
        context = get_publisher().context
        source_catalog = context.get_source_catalog()
        complete_term_map = source_catalog.get_complete_mapping()
        results = records_by_journal_index(context, complete_term_map)
        values = [r[2] for r in results]
        try:
            l = str(request.get_form_var('l', 'A')).upper()
            if not len(l) == 1 \
                or not l in string.ascii_uppercase:
                raise ValueError
        except ValueError:
            l = 'A'
        self.letter_index(values, l, text='Journals by letter:')
        if l:
            results = [r for r in results if r[2][0].upper() == l]
                        
        
        """
        <div id="table-list">
            <table cellspacing='3'>
                <tr>
                    <th align='center' width='75'># articles</th>
                    <th align='left'>Journal</th>
                </tr>
        """
        
        for result in results:
            count, issn, title, abbr = result
            if str('.') in title:
                title = title[0:title.index(str('.'))]
                """
                <tr>
                    <td style='text-align:center;'>%s</td>
                    <td style='text-align:left'><a href='/browse/journal/%s'>%s</a></td>
                </tr>
                """ % (count, issn, title)
            else:
                continue
    
        """
            </table>
        </div>
        """
        footer()

    def _q_lookup (self, request, issn=0):
        try:
            if issn:
                context = get_publisher().context
                source_catalog = context.get_source_catalog()
                complete_term_map = source_catalog.get_complete_mapping()
                title, records = records_by_journal(context, issn, 
                    term_map=complete_term_map)
                if len(records) == 0:
                    raise Exception('No records found')
                if str('.') in title:
                    title = title[0:title.index(str('.'))]
                else:
                    title = '-'
    
                return self.render_records(title, records)
        except:
            return not_found(self.type)
            


class MethodologyBrowseIndex (BrowseIndex):
        
    SORT_FIELDS = ['year', 'journal', '1au']

    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True

    def __init__ (self, request):
        self.type = 'methodology'
        
    def _q_index [html] (self, request):

        header('Browse by Methodology')
        """
        <h2>Browse by Methodology</h2>
    
        <p>
    The Canary database curators determine, for each included study, the type
    of methodology employed by the researchers (using <a
    href='/about/classification_protocol'>this classification protocol</a>).  For
    detailed explanations of each, see our <a 
    href='/about/study_methodologies'>study methodology overview</a>.
        </p>
    
        <p>
    Below is a list of the number of articles in the Canary Database by their
    methodology.
        </p>
    
        <div id="table-list">
            <table cellspacing='3'>
                <tr>
                    <th align='center' width='75'># articles</th>
                    <th align='left'>Methodology</th>
                </tr>
        """
        context = get_publisher().context
        records = records_by_methodology_index(context)
        meths = [(Methodology().get_text_value(Methodology.TYPES, 
                meth_id), meth_id, count) for meth_id, count in records]
        meths.sort()
        for meth_name, meth_id, count in meths:
            """
                <tr>
                    <td align='center'>%s</td>
                    <td align='left'><a href='/browse/methodology/%s'>%s</a></td>
                </tr>
            """ % (count, meth_id, meth_name.capitalize())
        """
            </table>
        </div>
        """
        footer()


    def _q_lookup (self, request, name):
        try:
            if name:
                meth_id = int(name)
                context = get_publisher().context
                records = records_by_methodology(context, meth_id)
                if len(records) == 0:
                    raise Exception('No records found')
                
                return self.render_records(Methodology().get_text_value(Methodology.TYPES,
                    meth_id).capitalize(), records)
            else:
                raise Error
        except:
            return not_found(self.type)
            
    


class AuthorBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
    
    SORT_FIELDS = ['year', 'journal', '1au']
    
    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True
    
    def __init__ (self, request):
        self.type = 'author'
        
    def _q_index [html] (self, request):

        header('Browse by %s' % self.type.capitalize())
        """
        <h2><a href='/browse/author'>Browse by Author</a></h2>
        """
        
        context = get_publisher().context
        results = records_by_author_index(context)
        values = [r[1] for r in results]
        try:
            l = str(request.get_form_var('l', 'A')).upper()
            # Only accept actual letters.
            if not len(l) == 1 \
                or not l in string.ascii_uppercase:
                raise ValueError
        except ValueError:
            l = 'A'
        self.letter_index(values, l, text='Authors by letter:')
        if l:
            results = [r for r in results if r[1][0].upper() == l]
                        
        if results:
            """
            <div id="table-list">
                <table cellspacing='3'>
                    <tr>
                        <th align='center' width='75'># articles</th>
                        <th align='left'>Author</th>
                    </tr>
            """
            
            for result in results:
                count, author = result
                """
                    <tr>
                        <td style='text-align:center;'>%s</td>
                        <td style='text-align:left'><a href='/browse/author/%s'>%s</a></td>
                    </tr>
                """ % (count, author, author)
                
            """
                </table>
            </div>
            """
        else:
            """
            <p>
            No authors found starting with that letter.
            </p>
            """
        footer()
        

    def _q_lookup (self, request, author=''):
        context = get_publisher().context
        try:
            if author:
                records = records_by_author(context, author)
                if len(records) == 0:
                    raise Exception('No records found')
                return self.render_records(author, records)
        except:
            return not_found(self.type)



class ConceptBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
    
    SORT_FIELDS = ['year', 'journal', '1au']
    
    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True
    
    def __init__ (self, request, concept):
        self.type = concept
        
    def _q_index [html] (self, request):

        context = get_publisher().context
        display_type = self.type.replace(str('_'), str(' ')).capitalize()
        
        header('Browse by %s' % display_type)
        """
        <h2><a href='/browse/%s'>Browse by %s</a></h2>
        """ % (self.type, display_type)
        
        results = records_by_concept_index(context, self.type)
        values = [r[2] for r in results]
        try:
            l = str(request.get_form_var('l', 'A')).upper()
            # Only accept actual letters or numbers.
            if not len(l) == 1 \
                or not l in string.ascii_uppercase + string.digits:
                raise ValueError
        except ValueError:
            l = 'A'
        
        # We don't want to see leading numbers for anything but exposures
        # and outcomes.
        show_numbers = False
        if self.type in ('exposure', 'outcome'):
            show_numbers = True
            
        self.letter_index(values, l, text='%s by letter:' % self.type, 
            show_numbers=show_numbers)

        if l:
            results = [r for r in results if r[2][0].upper() == l]
                        
        if results:
            """
            <div id="table-list">
                <table cellspacing='3'>
                    <tr>
                        <th align='center' width='75'># articles</th>
                        <th align='left'>%s</th>
                    </tr>
            """ % display_type
            
            for result in results:
                count, concept_id, term = result
                """
                    <tr>
                        <td style='text-align:center;'>%s</td>
                        <td style='text-align:left'><a href='/browse/%s/%s'>%s</a></td>
                    </tr>
                """ % (count, self.type, concept_id, term)
                
            """
                </table>
            </div>
            """
        else:
            """
            <p>
            No %s found starting with that letter.
            </p>
            """ % display_type
        footer()
        

    def _q_lookup (self, request, concept_id=''):
        context = get_publisher().context
        try:
            concept_id = int(concept_id)
            if concept_id:
                records = records_by_concept(context, self.type, concept_id)
                if len(records) == 0:
                    raise Exception('No records found')
                concept = Concept(context, concept_id)
                return self.render_records(concept.term, records)
        except:
            return not_found(self.type)
