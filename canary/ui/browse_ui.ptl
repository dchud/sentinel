# $Id$

import logging
import string
import traceback
import urllib

from quixote import get_publisher, get_request
from quixote.html import htmltext

from canary.browse import records_by_year, records_by_year_index
from canary.browse import records_by_heading, records_by_heading_index
from canary.browse import records_by_journal, records_by_journal_index
from canary.browse import records_by_methodology, records_by_methodology_index
from canary.browse import records_by_author, records_by_author_index
from canary.browse import records_by_concept, records_by_concept_index
from canary.concept import Concept, find_concepts
from canary.qx_defs import NotLoggedInError
from canary.resolver import find_resolver
from canary.study import Methodology, Study
from canary.summary import summary_set_from_concept
from canary.ui.pages import not_found
from canary.ui.pageframe import header, footer
from canary.ui.record_ui import render_record_row, data_points
from canary import utils


class Browse:

    _q_exports = [
        '_q_index',
        ]
        
    def __init__ (self, request):
        pass

    def _q_index [html] (self, request):
        header('Browse')
        """
        <h2>Browse</h2>
        
        <p>
        You can browse the database by clicking on the available 
        indexes under "Browse by" at left.
        </p>
        """
        footer()
    
    def _q_lookup (self, request, name):
        try:
            if name == 'year':
                return YearBrowseIndex(request)
            #elif name == 'heading':
            #    return HeadingBrowseIndex(request)
            elif name == 'journal':
                return JournalBrowseIndex(request)
            elif name == 'methodology':
                return MethodologyBrowseIndex(request)
            elif name == 'author':
                return AuthorBrowseIndex(request)
            elif name == 'exposure':
                return ConceptBrowseIndex(request, 'exposure')
            elif name == 'outcome':
                return ConceptBrowseIndex(request, 'outcome')
            elif name == 'species':
                return ConceptBrowseIndex(request, 'species')
            elif name == 'risk_factor':
                return ConceptBrowseIndex(request, 'risk_factor')
            else:
                raise 'NotFoundError'
        except:
            return not_found('index')
            

def render_on_this_page_concept [html] (type, concept_sorted, total, query_string=''):
    context = get_publisher().context
    request = get_request()
    
    f = request.get_form_var('f', '')
    filter_str = ''
    if f:
        filter_str = 'f=%s&' % f
        
    """
        <tr style='background-color:#fafafa;'>
            <td colspan='3' align='left'>
            <h3 style='font-size:12;margin-top:.6em;margin-bottom:.2em;'>%s</h3>
            </td>
        </tr>
    """ % type.capitalize()
    for count, con in concept_sorted[0:8]:
        if type == 'author':
            """
            <tr style='background-color:#fafafa;'>
                <td style='margin-right:.3em;' valign='top'>
                    <a style='font-size:11px;' 
                        href='/search?%sq="%s"[%s]'
                        title='Search for: "%s" [%s]'>%s</a>
                </td>
            """ % (str(filter_str), con, type, 
                con, type, con)
            query = '"%s"[%s]' % (con, type)
        else:
            concept = Concept(context, con)
            """
            <tr style='background-color:#fafafa;'>
                <td style='margin-right:.3em;' valign='top'>
                    <a style='font-size:11px;' 
                        href='/browse/%s/%s'
                        title='Browse %s "%s"'>%s</a>
                </td>
            """ % (type, con, 
                type, concept.term, concept.term)
            # Hack 
            query = '"%s"[%s]' % (concept.term, type)
        or_query = and_query = query_string
        if not str(query) in str(query_string):
            or_query = '%s OR %s' % (query_string, query)
            and_query = '%s %s' % (query_string, query)
        """
            <td valign='top'>
                <a href='/search?%sq=%s' title='Search for: %s'><img src='/images/basic-boolean-and.jpg' alt='Search for: %s' border='0'/></a>
            </td>
            <td valign='top'>
                <a href='/search?%sq=%s' title='Search for: %s'><img src='/images/basic-boolean-or.jpg' alt='Search for: %s' border='0'/></a>
            </td>
        """ % (str(filter_str), and_query, and_query, and_query,
            str(filter_str), or_query, or_query, or_query)
        """
        </tr>
        """

def render_now_showing [html] (request, user, query_string=""):
    context = get_publisher().context
    config = context.config
    
    """
    <h3>Now showing:</h3>
    """
    f = request.get_form_var('f', None)
    mode = 'All records'
    if f:
        try:
            if f == 'user':
                mode = 'My records'
            elif f.startswith(str('set-')):
                set_id = int(str(f)[4:])
                set = [s for s in user.sets if s.uid == set_id][0]
                mode = 'My set "%s"' % set.name
        except:
            print traceback.print_exc()
    
    domains = [
        (None, 'All records', -1), 
        ('user', 'My records', -1),
        ]
    for set in user.sets:
        domains.append(('set-%s' % set.uid, 'My set "%s"' % set.name, set.uid))
    
    options = []
    for fval, d, set_id in domains:
        """
        <span class='similar_row'>
        """
        if mode == d:
            """
            <span class="bold">%s</span><br />
            """ % d
        else:
            str_qs = str(query_string)
            if str_qs.startswith(str('"all my records')) \
                or str_qs.startswith(str('"my set ')):
                # Make the links do what users expect: browse "my records" or
                # "my set foo" if there's *no* search/browse context already
                if d == 'All records':
                    # Note: browsing all records doesn't make sense, so no link
                    """
                    <span>All records</span> <br />
                    """
                elif d == 'My records':
                    """
                    <a href='%s/user/set/'>My records (%s)</a> <br />
                    """ % (config.site_base_url, len(user.records))
                else:
                    # It's a set
                    """
                    <a href='%s/user/set/%s/'>%s (%s)</a><br />
                    """ % (config.site_base_url, set_id, str(d), len(user.record_set_map.get(set_id, [])))
            else:
                """
                <a href='%s/search?f=%s&amp;q=%s'>%s</a><br />
                """ % (config.site_base_url, str(fval), query_string, str(d))
        """
        </span>
        """
    """
    <br />
    """

def render_on_this_page [html] (records, query_string='', study_map=[]):
    context = get_publisher().context
    config = context.config
    source_catalog = context.get_source_catalog()
    complete_term_map = source_catalog.get_complete_mapping()
    
    request = get_request()
    try:
        user = request.session.user
    except:
        user = None
    
    num_records = len(records)
    authors = {}
    exposures = {}
    outcomes = {}
    species = {}
    for sort_value, rec in records:
        try:
            study = study_map[str('%s:%s' % (Study.CACHE_KEY, rec.study_id))]
        except:
            study = Study(context, rec.study_id)
        mm = rec.get_mapped_metadata(complete_term_map)
        author = mm['author']
        for a in author:
            try:
                authors[a] += 1
            except KeyError:
                authors[a] = 1
        for exp in study.exposures:
            try:
                exposures[exp.concept_id] += 1
            except KeyError:
                exposures[exp.concept_id] = 1
        for out in study.outcomes:
            try:
                outcomes[out.concept_id] += 1
            except KeyError:
                outcomes[out.concept_id] = 1
        for spec in study.species:
            try:
                species[spec.concept_id] += 1
            except KeyError:
                species[spec.concept_id] = 1
        
    
    """
    <div id='similar_box'>
    """
    if user:
        render_now_showing(request, user, query_string)
    
    if records:
        """
        <h3>Find similar:</h3>
        
        <div class='similar'>
        <table width='100%' border='0' cellspacing='1' cellpadding='0'>
            <tr class='similar_row'>
                <th style='font-size:11px;'>term</th>
                <th style='font-size:11px;'>and</th>
                <th style='font-size:11px;'>&nbsp;or</th>
            </tr>
        """
        
        exposures_sorted = [(v, k) for k, v in exposures.items()]
        exposures_sorted.sort()
        exposures_sorted.reverse()
        if exposures_sorted:
            render_on_this_page_concept('exposure', exposures_sorted, num_records,
                query_string)
    
        outcomes_sorted = [(v, k) for k, v in outcomes.items()]
        outcomes_sorted.sort()
        outcomes_sorted.reverse()
        if outcomes_sorted:
            render_on_this_page_concept('outcome', outcomes_sorted, num_records,
                query_string)
                
        species_sorted = [(v, k) for k, v in species.items()]
        species_sorted.sort()
        species_sorted.reverse()
        if species_sorted:
            render_on_this_page_concept('species', species_sorted, num_records,
                query_string)
                
        authors_sorted = [(v, k) for k, v in authors.items()]
        authors_sorted.sort()
        authors_sorted.reverse()
        if authors_sorted:
            render_on_this_page_concept('author', authors_sorted, num_records,
                query_string)
                
        """
        </table>
        """
    """
    </div>
    """
            
    

class BrowseIndex:
    
    _q_exports = [
        '_q_index',
        ]
    
    # Subclasses can be sorted by any of these attributes
    SORT_FIELDS = ['year']
    
    # Subclasses are sorted by default by this attribute
    SORT_FIELD_DEFAULT = 'year'
    
    # Subclasses are sorted by default in this order
    SORT_BY_DESCENDING = True

    # Supported pager sizes; anything else will be ignored
    ALLOWED_SIZES = (10, 25, 50, 100)

    def __init__ (self):
        self.type = 'superclass'
        self.logger = logging.getLogger(str(self.__class__))
        
    def _q_index [html] (self, request):
        pass
        
    def get_pager_params (self):
        """
        Fetch requested or provide default pager parameters, ignoring
        improper value types.
        """
        request = get_request()
        params = {}
        
        try:
            params['size'] = int(request.get_form_var('size', 10))
            if not params['size'] in self.ALLOWED_SIZES:
                raise ValueError
        except ValueError:
            params['size'] = 10
            
        try:
            params['start'] = int(request.get_form_var('start', 0))
        except ValueError:
            params['start'] = 0
            
        try:
            sort_by = str(request.get_form_var('sort_by', 
                self.SORT_FIELD_DEFAULT))
            if sort_by in self.SORT_FIELDS:
                params['sort_by'] = sort_by
            else:
                raise ValueError
        except ValueError:
            params['sort_by'] = self.SORT_FIELD_DEFAULT
        
        try:
            sort_desc = int(request.get_form_var('sort_desc', 
                int(self.SORT_BY_DESCENDING)))
            if sort_desc in (0, 1):
                params['sort_desc'] = sort_desc
            else:
                raise ValueError
        except ValueError:
            params['sort_desc'] = int(self.SORT_BY_DESCENDING)
            
        return params


    def pager [html] (self, records, params={}):
        
        p = params
        total = len(records)
       
        # total number of pages, by size, in this list
        num_pages = total / p['size']
        remainder = total % p['size']
        if remainder:
            num_pages += 1
    
        # currently viewed page, as determined by size, within this list
        cur_page = p['start'] / p['size']
        """
        <p>
        """
        if len(records) >= 2:
            """
            Sort by:
            """
            for sort_field in self.SORT_FIELDS:
                if sort_field == p['sort_by']:
                    ' [<b>%s</b>] ' % sort_field
                else:
                    ' [<a href="?size=%s&sort_by=%s&sort_desc=%s">%s</a>] ' % \
                        (p['size'], sort_field, p['sort_desc'], sort_field)
            
            """
            &nbsp;-&nbsp;
            """
            if 'year' == p['sort_by']:
                text_asc = '0-9'
                text_desc = '9-0'
            else:
                text_asc = 'A-Z'
                text_desc = 'Z-A'
                
            if p['sort_desc']:
                ' [<a href="?size=%s&sort_by=%s&sort_desc=0">%s</a>] ' % \
                    (p['size'], p['sort_by'], text_asc)
                ' [<b>%s</b>] ' % text_desc
            else:
                ' [<b>%s</b>] ' % text_asc
                ' [<a href="?size=%s&sort_by=%s&sort_desc=1">%s</a>] ' % \
                    (p['size'], p['sort_by'], text_desc)

        # no need to show the pager if there's only one page
        if num_pages > 1:

            # We only need the spacing if there's a "sort by" above it
            if len(records) >= 2:
                """
                <br />
                """
                
            """
            Show:
            """    
            sizes = [min(self.ALLOWED_SIZES)]
            if total > max(self.ALLOWED_SIZES):
                sizes.extend(self.ALLOWED_SIZES[1:])
            else:
                # Don't show "group by 100" if there are only 13 records
                for bigger_size in self.ALLOWED_SIZES[1:]:
                    if not max(sizes) > total:
                        sizes.append(bigger_size)
                
            for s in sizes:
                text = s
                if s == total:
                    text = 'all'
                    
                if p['size'] == s:
                    ' [<b>%s</b>] ' % text
                else:
                    ' [<a href="?size=%s&sort_by=%s&sort_desc=%s">%s</a>] ' % \
                        (s,  p['sort_by'], p['sort_desc'], text)
            """
            per page <br />
            """
            
            """
            Go to: 
            """
            for i in range(0, num_pages):
                start = str((i * p['size']) + 1)
                if remainder \
                    and (i+1) == num_pages:
                    end = str((i * p['size']) + remainder)
                else:
                    end = str((i + 1) * p['size'])
                text = start + '-' + end
                if i != cur_page:
                    ' [<a href="?start=%s&size=%s&sort_by=%s&sort_desc=%s">%s</a>] ' % \
                        (i * p['size'], p['size'], p['sort_by'], p['sort_desc'], text)
                else:
                    ' [<b>%s</b>] ' % text
            
        """
        </p>
        """


    
    def letter_index [html] (self, values, current_value=None, text='',
        show_numbers=False):
        # Generate a browse-by-letter index view 
        lindex = {}
        for c in range(65, 91):
            lindex[chr(c)] = 0
        if show_numbers:
            for i in range(0,10):
                lindex[str(i)] = 0
                
        for val in [v[0].capitalize() for v in values]:
            lindex[val] += 1
        
        """
        <p>
        %s
        """ % text or 'Starting with:'
        
        keys = lindex.keys()
        keys.sort()
        for key in keys:
            if lindex[key]:
                if key == current_value.upper():
                    """
                    [<b>%s</b>]
                    """ % key
                else:
                    """
                    [<a href='?l=%s'>%s</a>]
                    """ % (key, key)
            else:
                """
                %s
                """ % key
        
        """
        </p>
        """



    def render_records [html] (self, name, records, filter_by=''):
        context = get_publisher().context
        source_catalog = context.get_source_catalog()
        complete_term_map = source_catalog.get_complete_mapping()
            
        ip_address = get_request().get_environ('REMOTE_ADDR')
        try:
            resolver = find_resolver(context, ip_address)
            if not resolver:
                raise 'NoResolverFound'
        except:
            print 'No resolver for ip %s: %s' % (ip_address, traceback.print_exc())
            resolver = None
            
        type_display = self.type.replace(str('_'), str(' '))
        type_search = self.type.replace(str('_'), str('-'))
        header('Browse by %s: %s' % (type_display.capitalize(), name),
            show_javascript=True)
        
        filter_str = 'q='
        if filter_by == 'user':
            filter_str = 'f=user&q='
        elif filter_by.startswith('set-'):
            # Verify it's an int
            try:
                set_id = int(str(filter_by)[4:])
                filter_str = 'f=%s&q=' % filter_by
            except ValueError:
                pass
        
        count = len(records)
        if count == 0:
            """
            <h2>No records found</h2>
            
            <p>
            No records found in '%s'.
            </p>
            """ % name
        else:
            if count == 1:
                article_text = 'article'
            else:
                article_text = 'articles'
    
            """
            <h2><a href='/browse/%s'>Browse by %s</a>: %s (%s %s)</h2>
            """ % (self.type, type_display.capitalize(), name,
                count, article_text)
            
            try:
                year_count = {}
                for i in range(1965, 2007):
                    year_count[i] = 0
                for rec in records:
                    mm = rec.get_mapped_metadata(term_map=complete_term_map)
                    try:
                        year = int(mm['pubdate'][:4])
                        year_count[year] += 1
                    except:
                        # Somehow the first four digits of pubdate aren't YYYY
                        continue
                        
                        
                # Process all paging info up front so we can optionally
                # pass context years for a subset into make_sparkline()
                        
                years = year_count.keys()
                years.sort()
                p = self.get_pager_params()

                sort_by = p['sort_by']
                records_sorted = []
                for record in records:
                    mm = record.get_mapped_metadata(complete_term_map)
                    if sort_by == 'year':
                        sort_value = mm[str('pubdate')][:4]
                    elif sort_by == 'journal':
                        sort_value = mm[str('journal')].lower()
                    elif sort_by == '1au':
                        authors = mm[str('author')]
                        if authors:
                            sort_value = authors[0].lower()
                        else:
                            sort_value = ''
                    else:
                        pass
                    records_sorted.append((sort_value, record))
                        
                records_sorted.sort()
                if p['sort_desc']:
                    records_sorted.reverse()
                    
                start = p['start']
                end = start + p['size']
                records_sliced = records_sorted[start:end]
                
                # Only shade the year-context in the sparkline if it's a 
                # year sort.
                if records_sliced \
                    and p['sort_by'] == 'year':
                    try:
                        start_mm = records_sliced[0][1].get_mapped_metadata(complete_term_map)
                        min_year = max_year = int(start_mm[str('pubdate')][:4])
                        for sort_value, rec in records_sliced[1:]:
                            mm = rec.get_mapped_metadata(complete_term_map)
                            year = int(mm[str('pubdate')][:4])
                            if year < min_year:
                                min_year = year
                            if year > max_year:
                                max_year = year
                            
                        sparkline_image_file = utils.make_sparkline(context, year_count, 
                            context_years=(min_year, max_year))
                    except Exception, e:
                        self.logger.error('Could not specify context years: %s', e)
                        sparkline_image_file = utils.make_sparkline(context, year_count)
                else:
                    sparkline_image_file = utils.make_sparkline(context, year_count)
                
                try:
                    studies = [Study(context, rec.study_id) for sort_value, rec in records_sorted]
                except:
                    context.logger.error(traceback.print_exc())

                """
                <p>
                %s of records by year:
                    <span style='font-weight:bold;font-size:x-small;'>1965</span>
                    <img border='0' src='/timage/%s' type='image/png' 
                        alt='Small chart of records by year' usemap='#sparkmap'/>
                    <span style='font-weight:bold;font-size:x-small;'>2007</span>
                </p>
                """ % ('%', sparkline_image_file)
                
                """
                <map name='sparkmap'>
                """
                # rect order is: left-x, top-y, right-x, bottom-y
                for year in years:
                    count = year_count[year]
                    if count > 0:
                        year_index = years.index(year)
                        if filter_str:
                            query_str = filter_str + '%s [date]' % year
                        else:
                            query_str = '"%s" [%s] %s [date]' \
                                % (name, type_search, year)
                        """
                    <area href='/search?%s' 
                        shape='rect'
                        coords='%s %s %s %s'
                        alt='%s'
                        title='%s' />
                        """ % (query_str,
                            year_index*3, 0, (year_index*3)+2, 120,
                            'limit to year %s' % year,
                            'limit to year %s' % year)
                """
                </map>
                """
                
                try:
                    if getattr(self, str('concept'), None):
                        summary_set = summary_set_from_concept(context, 
                            self.concept.uid, type_search)
                        if summary_set:
                            summary = summary_set.summarize(context)
                            if summary:
                                """
                                <div id='summary-hype'>
                                    <img src='/images/24-em-check.png' />
                                    <span class='large'>/</span>
                                    <img src='/images/20-px-negative.png' />
                                    &nbsp;<a href='/summary/%s/%s'>See the Canary summary for %s</a>
                                    <img src='/images/24-em-check.png' />
                                    <span class='large'>/</span>
                                    <img src='/images/20-px-negative.png' />
                                </div>
                                """ % (self.type, self.concept.uid, self.concept.term)
                except:
                    print traceback.print_exc()
                    
                    
                """
                <table width='100%' border='0' cellspacing='0' cellpadding='0'>
                <tr>
                    <td valign='top'>
                """
                self.pager(records, params=p)
                """
                <div id="search-result">
                    <table width='100%' border='0' cellspacing='0' cellpadding='0'>
                """
                for sort_val, rec in records_sliced:
                    if resolver:
                        render_record_row(rec, resolver)
                    else:
                        render_record_row(rec)
                """
                    </table>
                </div>
                """
                self.pager(records, params=p)
                """
                    </td>
                    
                    <td width='30%' valign='top'>
                """
                render_on_this_page(records_sliced, '"%s"[%s]' % (name, 
                    type_search))
                """
                    </td>
                </tr>
                </table>
                """
                
            except:
                context.logger.error(traceback.print_exc())
                return not_found(self.type)
            
        footer()




class UserSetBrowseIndex (BrowseIndex):
    
    SORT_FIELDS = ['year', 'journal', '1au']
    
    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = False
    
    def __init__ (self, request):
        self.type = 'year'
        self.logger = logging.getLogger(str(self.__class__))
        
    
class YearBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
        
    SORT_FIELDS = ['journal', '1au']
    
    SORT_FIELD_DEFAULT = '1au'
    
    SORT_BY_DESCENDING = False
    
    def __init__ (self, request):
        self.type = 'year'
        self.logger = logging.getLogger(str(self.__class__))
        
    def _q_index [html] (self, request):
        header('Browse by Year')
        """
        <h2>Browse by Year</h2>
    
        <p>
    Below is a list of the number of articles in the Canary Database by their
    year of publication.
        </p>
    
        <div id="table-list">
            <table cellspacing='3'>
                <tr>
                    <th align='center' width='75'># articles</th>
                    <th align='left'>Year</th>
                </tr>
        """
        context = get_publisher().context
        source_catalog = context.get_source_catalog()
        complete_term_map = source_catalog.get_complete_mapping()
        records = records_by_year_index(context, complete_term_map)
        for record in records:
            year_count, year = record
            if not year == 0:
                """
                <tr>
                    <td align='center'>%s</td>
                    <td align='center'><a href='/browse/year/%s'>%s</a></td>
                </tr>
                """ % (year_count, year, year)
        """
            </table>
        </div>
        """
        footer()
        

    def _q_lookup (self, request, year):
        try:
            if year:
                year = int(year)
                context = get_publisher().context
                source_catalog = context.get_source_catalog()
                complete_term_map = source_catalog.get_complete_mapping()
                records = records_by_year(context, year, term_map=complete_term_map)
                if len(records) == 0:
                    raise Exception('No records found')
                return self.render_records(year, records)
            else:
                raise Error
        except:
            return not_found(self.type)
            



class HeadingBrowseIndex (BrowseIndex):

    _q_exports = [
        '_q_index',
        ]
        
    def __init__ (self, request):
        self.type = 'heading'
        
    def _q_index [html] (self, request):
        header('Browse by Heading')
        """
        <h2>Browse by Heading</h2>
    
        <p>
        Below is a list of the most well-used MeSH headings (indexed by
        NLM) as found in our curated articles.  Please note that in many
        cases, a single article might be indexed with the same heading multiple
        times, when multiple qualifers are attached to the MeSH heading:
        <ul>
            <li>'<b># uses</b>' is the total number of times a heading
        appears as an index term;</li>
            <li>'<b># articles</b>' is the total number of articles in which
        the same heading appears as an index term at least once.</li>
        </ul>
        </p>
        """
    
        """
        <table width='70%' cellspacing='3' cellpadding='3'>
            <tr>
                <th align='center' width='20%'># uses</th>
                <th align='center' width='15%'># articles</th>
                <th align='left'>Subject heading</th>
            </tr>
        """
        context = get_publisher().context
        headings = records_by_heading_index(context)
        for heading in headings:
            term, term_count, id_count = heading
            encoded_heading = urllib.quote_plus(term)
            """
            <tr>
                <td align='center'>%(term_count)s</td>
                <td align='center'>%(id_count)s</td>
                <td align='left'><a href='/browse/heading/%(encoded_heading)s'>%(term)s</a></td>
            </tr>
            """ % vars()
        """
        </table>
        """
        footer()

    
    def _q_lookup (self, request, name):
        try:
            if name:
                unencoded_name = urllib.unquote_plus(name)
                records = records_by_heading(unencoded_name)
                return self.render_records(unencoded_name, records)
            else:
                raise Error
        except:
            return not_found(self.type)
            



class JournalBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
    
    SORT_FIELDS = ['year', '1au']
    
    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True
    
    def __init__ (self, request):
        self.type = 'journal'
        
    def _q_index [html] (self, request):

        header('Browse by %s' % self.type.capitalize())#, show_javascript=True)
        """
        <h2><a href='/browse/journal'>Browse by Journal</a></h2>
        """
        
        context = get_publisher().context
        source_catalog = context.get_source_catalog()
        complete_term_map = source_catalog.get_complete_mapping()
        results = records_by_journal_index(context, complete_term_map)
        values = [r[2] for r in results]
        try:
            l = str(request.get_form_var('l', 'A')).upper()
            if not len(l) == 1 \
                or not l in string.ascii_uppercase:
                raise ValueError
        except ValueError:
            l = 'A'
        self.letter_index(values, l, text='Journals by letter:')
        if l:
            results = [r for r in results if r[2][0].upper() == l]
                        
        
        """
        <div id="table-list">
            <table cellspacing='3'>
                <tr>
                    <th align='center' width='75'># articles</th>
                    <th align='left'>Journal</th>
                </tr>
        """
        
        for result in results:
            count, issn, title, abbr = result
            if str('.') in title:
                title = title[0:title.index(str('.'))]
                """
                <tr>
                    <td style='text-align:center;'>%s</td>
                    <td style='text-align:left'><a href='/browse/journal/%s'>%s</a></td>
                </tr>
                """ % (count, issn, title)
            else:
                continue
    
        """
            </table>
        </div>
        """
        footer()

    def _q_lookup (self, request, issn=0):
        try:
            if issn:
                context = get_publisher().context
                source_catalog = context.get_source_catalog()
                complete_term_map = source_catalog.get_complete_mapping()
                title, records = records_by_journal(context, issn, 
                    term_map=complete_term_map)
                if len(records) == 0:
                    raise Exception('No records found')
                if str('.') in title:
                    title = title[0:title.index(str('.'))]
                else:
                    title = '-'
    
                return self.render_records(title, records)
        except:
            return not_found(self.type)
            


class MethodologyBrowseIndex (BrowseIndex):
        
    SORT_FIELDS = ['year', 'journal', '1au']

    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True

    def __init__ (self, request):
        self.type = 'methodology'
        
    def _q_index [html] (self, request):

        header('Browse by Methodology')
        """
        <h2>Browse by Methodology</h2>
    
        <p>
    The Canary database curators determine, for each included study, the type
    of methodology employed by the researchers (using <a
    href='/about/classification_protocol'>this classification protocol</a>).  For
    detailed explanations of each, see our <a 
    href='/about/study_methodologies'>study methodology overview</a>.
        </p>
    
        <p>
    Below is a list of the number of articles in the Canary Database by their
    methodology.
        </p>
    
        <div id="table-list">
            <table cellspacing='3'>
                <tr>
                    <th align='center' width='75'># articles</th>
                    <th align='left'>Methodology</th>
                </tr>
        """
        context = get_publisher().context
        records = records_by_methodology_index(context)
        meths = [(Methodology().get_text_value(Methodology.TYPES, 
                meth_id), meth_id, count) for meth_id, count in records]
        meths.sort()
        for meth_name, meth_id, count in meths:
            """
                <tr>
                    <td align='center'>%s</td>
                    <td align='left'><a href='/browse/methodology/%s'>%s</a></td>
                </tr>
            """ % (count, meth_id, meth_name.capitalize())
        """
            </table>
        </div>
        """
        footer()


    def _q_lookup (self, request, name):
        try:
            if name:
                meth_id = int(name)
                context = get_publisher().context
                records = records_by_methodology(context, meth_id)
                if len(records) == 0:
                    raise Exception('No records found')
                
                return self.render_records(Methodology().get_text_value(Methodology.TYPES,
                    meth_id).capitalize(), records)
            else:
                raise Error
        except:
            return not_found(self.type)
            
    


class AuthorBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
    
    SORT_FIELDS = ['year', 'journal', '1au']
    
    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True
    
    def __init__ (self, request):
        self.type = 'author'
        
    def _q_index [html] (self, request):

        header('Browse by %s' % self.type.capitalize())
        """
        <h2><a href='/browse/author'>Browse by Author</a></h2>
        """
        
        context = get_publisher().context
        results = records_by_author_index(context)
        values = [r[1] for r in results]
        try:
            l = str(request.get_form_var('l', 'A')).upper()
            # Only accept actual letters.
            if not len(l) == 1 \
                or not l in string.ascii_uppercase:
                raise ValueError
        except ValueError:
            l = 'A'
        self.letter_index(values, l, text='Authors by letter:')
        if l:
            results = [r for r in results if r[1][0].upper() == l]
                        
        if results:
            """
            <div id="table-list">
                <table cellspacing='3'>
                    <tr>
                        <th align='center' width='75'># articles</th>
                        <th align='left'>Author</th>
                    </tr>
            """
            
            for result in results:
                count, author = result
                """
                    <tr>
                        <td style='text-align:center;'>%s</td>
                        <td style='text-align:left'><a href='/browse/author/%s'>%s</a></td>
                    </tr>
                """ % (count, author, author)
                
            """
                </table>
            </div>
            """
        else:
            """
            <p>
            No authors found starting with that letter.
            </p>
            """
        footer()
        

    def _q_lookup (self, request, author=''):
        context = get_publisher().context
        try:
            if author:
                records = records_by_author(context, author)
                if len(records) == 0:
                    raise Exception('No records found')
                return self.render_records(author, records)
        except:
            return not_found(self.type)



class ConceptBrowseIndex (BrowseIndex):
    
    _q_exports = [
        '_q_index',
        ]
    
    SORT_FIELDS = ['year', 'journal', '1au']
    
    SORT_FIELD_DEFAULT = 'year'
    
    SORT_BY_DESCENDING = True
    
    def __init__ (self, request, concept):
        self.type = concept
        
    def _q_index [html] (self, request):

        context = get_publisher().context
        type_display = self.type.replace(str('_'), str(' ')).capitalize()
        
        header('Browse by %s' % type_display)
        """
        <h2><a href='/browse/%s'>Browse by %s</a></h2>
        """ % (self.type, type_display)
        
        results = records_by_concept_index(context, self.type)
        values = [r[2] for r in results]
        try:
            l = str(request.get_form_var('l', 'A')).upper()
            # Only accept actual letters or numbers.
            if not len(l) == 1 \
                or not l in string.ascii_uppercase + string.digits:
                raise ValueError
        except ValueError:
            l = 'A'
        
        # We don't want to see leading numbers for anything but exposures
        # and outcomes.
        show_numbers = False
        if self.type in ('exposure', 'outcome'):
            show_numbers = True
            
        self.letter_index(values, l, text='%s by letter:' % self.type, 
            show_numbers=show_numbers)

        if l:
            results = [r for r in results if r[2][0].upper() == l]
                        
        if results:
            """
            <div id="table-list">
                <table cellspacing='3'>
                    <tr>
                        <th align='center' width='75'># articles</th>
                        <th align='left'>%s</th>
                    </tr>
            """ % type_display
            
            for result in results:
                count, concept_id, term = result
                """
                    <tr>
                        <td style='text-align:center;'>%s</td>
                        <td style='text-align:left'><a href='/browse/%s/%s'>%s</a></td>
                    </tr>
                """ % (count, self.type, concept_id, term)
                
            """
                </table>
            </div>
            """
        else:
            """
            <p>
            No %s found starting with that letter.
            </p>
            """ % type_display
        footer()
        

    def _q_lookup (self, request, concept_id=''):
        context = get_publisher().context
        try:
            self.concept_id = int(concept_id)
            if self.concept_id:
                records = records_by_concept(context, self.type, self.concept_id)
                if len(records) == 0:
                    raise Exception('No records found')
                self.concept = Concept(context, self.concept_id)
                return self.render_records(self.concept.term, records)
        except:
            return not_found(self.type)
